extern crate amcl;
extern crate tiny_keccak;
extern crate rand;

use self::amcl::arch::Chunk;
use self::tiny_keccak::Keccak;
use BLSCurve::big::BIG;
use BLSCurve::big::{MODBYTES as bls381_MODBYTES, NLEN};
use BLSCurve::ecp::ECP;
use BLSCurve::ecp2::ECP2;
use BLSCurve::fp12::FP12 as bls381_FP12;
use BLSCurve::fp2::FP2 as bls381_FP2;
use BLSCurve::pair::{ate, fexp};
use BLSCurve::rom;

pub type BigNum = BIG;
pub type GroupG1 = ECP;
pub type GroupG2 = ECP2;
pub type FP2 = bls381_FP2;
pub type FP12 = bls381_FP12;

pub const CURVE_ORDER: [Chunk; NLEN] = rom::CURVE_ORDER;
pub const MODBYTES: usize = bls381_MODBYTES;

// Byte size of element in group G1, 1 extra byte for compression
pub const G1_BYTE_SIZE: usize = (2 * MODBYTES + 1) as usize;
// Byte size of element in group G2
pub const G2_BYTE_SIZE: usize = (4 * MODBYTES) as usize;
// Byte size of secret key
pub const MOD_BYTE_SIZE: usize = bls381_MODBYTES;

// G2_Cofactor as arrays of i64
pub const G2_COFACTOR_HIGH: [Chunk; NLEN] = [
  0x01537E293A6691AE, 0x023C72D367A0BBC8, 0x0205B2E5A7DDFA62,
  0x01151C216AEA9A28, 0x012876A202CD91DE, 0x010539FC4247541E,
  0x000000005D543A95
];
pub const G2_COFACTOR_LOW: [Chunk; NLEN] = [
  0x031C38E31C7238E5, 0x01BB1B9E1BC31C33, 0x0000000000000161,
  0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
  0x0000000000000000
];
pub const G2_COFACTOR_SHIFT: [Chunk; NLEN] = [
  0x0000000000000000, 0x0000000000000000, 0x0000000000001000,
  0x0000000000000000, 0x0000000000000000, 0x0000000000000000,
  0x0000000000000000
];

lazy_static! {
    pub static ref GeneratorG1: GroupG1 = GroupG1::generator();
    pub static ref GeneratorG2: GroupG2 = GroupG2::generator();
}

// Take given message and domain and convert it to ECP2 point
pub fn hash_on_g2(msg: &[u8], d: u64) -> GroupG2 {
    // Converting to BIG requires 48 bytes, Keccak256 is only 32 bytes
    let mut x_real = vec![0 as u8; 16];
    x_real.append(&mut hash(&[msg, &d.to_be_bytes(), &[1]].concat()));
    let mut x_imaginary = vec![0 as u8; 16];
    x_imaginary.append(&mut hash(&[msg, &d.to_be_bytes(), &[2]].concat()));

    map_to_g2(&x_real, &x_imaginary)
}

// The following function is a modified version of ECP2::mapit()
// It varies in having both x_real and x_imaginary parts generated by different hashes
#[allow(non_snake_case)]
pub fn map_to_g2(x_real: &[u8], x_imaginary: &[u8]) -> GroupG2 {
    // Convery Hashes to BIGs mod q
    let q = BIG::new_ints(&rom::MODULUS);
    let mut x_real = BIG::frombytes(x_real);
    let mut x_imaginary = BIG::frombytes(x_imaginary);
    x_real.rmod(&q);
    x_imaginary.rmod(&q);
    let mut x = FP2::new_bigs(&x_real, &x_imaginary);

    let mut one = FP2::new();
    one.one();

    let mut curve_point: ECP2;

    // Continue increment x until valid y is found
    loop {
        x.norm();
        curve_point = GroupG2::new_fp2(&x);

        if !curve_point.is_infinity() {
            break;
        }
        x.add(&one);
    }

    // Take larger of two y values
    let mut y = curve_point.gety();
    let mut neg_y = curve_point.gety();
    neg_y.neg();
    if cmp_fp2(&mut y, &mut neg_y) < 0 {
        curve_point.neg();
    }

    // Multiply the point by given G2_Cofactor
    let curve_point = multiply_cofactor(&mut curve_point);

    curve_point
}

// Compare values of two FP2 elements,
// -1 if num1 < num2; 0 if num1 == num2; 1 if num1 > num2
pub fn cmp_fp2(num1:&mut FP2, num2:&mut FP2) -> isize {
    // First compare FP2.b
    let num1_b = num1.getb();
    let num2_b = num2.getb();
    let mut result = BIG::comp(&num1_b, &num2_b);

    // If FP2.b is equal compare FP2.a
    if result == 0 {
        let num1_a = num1.geta();
        let num2_a = num2.geta();
        result = BIG::comp(&num1_a, &num2_a);
    }
    result
}

// Multiply in parts by cofactor due to its size.
pub fn multiply_cofactor(curve_point: &mut ECP2) -> ECP2 {
    // Replicate curve_point for low part of multiplication
    let mut lowpart = ECP2::new();
    lowpart.copy(&curve_point);

    // Convert const arrays to BIGs
    let g2_cofactor_high = BIG::new_ints(&G2_COFACTOR_HIGH);
    let g2_cofactor_shift = BIG::new_ints(&G2_COFACTOR_SHIFT);
    let g2_cofactor_low = BIG::new_ints(&G2_COFACTOR_LOW);

    // Multiply high part, then low part, then add together
    let mut curve_point = curve_point.mul(&g2_cofactor_high);
    curve_point = curve_point.mul(&g2_cofactor_shift);
    let mut lowpart = lowpart.mul(&g2_cofactor_low);
    curve_point.add(&mut lowpart);
    curve_point
}

// Provides a Keccak256 hash of given input.
pub fn hash(input: &[u8]) -> Vec<u8> {
    let mut keccak = Keccak::new_keccak256();
    keccak.update(input);
    let mut result = vec![0; 32];
    keccak.finalize(result.as_mut_slice());
    result
}

// A pairing function for an ECP2 point and ECP point to FP12.
pub fn ate_pairing(point_g2: &GroupG2, point_g1: &GroupG1) -> FP12 {
    let e = ate(&point_g2, &point_g1);
    fexp(&e)
}

// Take a ECP point (x, y) and compress it to a 384 bit array.
pub fn compression_g1(g1: &GroupG1) -> Vec<u8> {
    // A compressed point takes form (c_flag, b_flag, a_flag, x-coordinate) where:
    // c_flag == 1
    // b_flag represents infinity (1 if infinitity -> x = y = 0)
    // a_flag = y % 2 (i.e. odd or eveness of y point)
    // x is the x-coordinate of

    // TODO: write this
    vec![0 as u8]
}

// Take a ECP2 point (x, y) and compress it to a 384*2 bit array.
pub fn compression_g2(g2: &GroupG2) -> Vec<u8> {
    // TODO: Write this
    vec![0 as u8]
}


// Test vectors found at https://github.com/ethereum/eth2.0-tests/blob/master/bls/test_bls.yml
#[cfg(test)]
mod tests {
    extern crate yaml_rust;
    extern crate hex;

    use super::*;
    use self::yaml_rust::yaml;
    use std::{fs::File, io::prelude::*, path::PathBuf};


    #[test]
    #[allow(non_snake_case)]
    fn case01_message_hash_G2_uncompressed() {
        // Run tests from test_bls.yml
        let mut file = {
            let mut file_path_buf = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
            file_path_buf.push("src/test_vectors/test_bls.yml");

            File::open(file_path_buf).unwrap()
        };
        let mut yaml_str = String::new();
        file.read_to_string(&mut yaml_str).unwrap();
        let docs = yaml::YamlLoader::load_from_str(&yaml_str).unwrap();
        let doc = &docs[0];

        // Select case01
        let test_cases = doc["case01_message_hash_G2_uncompressed"].as_vec().unwrap();

        // Verify input against output for each pair
        for test_case in test_cases {
            // Convert input to rust formats
            let input = test_case["input"].clone();
            // Convert domain from indexed yaml to u64
            let domain = input["domain"].as_str().unwrap();
            let domain = domain.trim_left_matches("0x");
            let domain = u64::from_str_radix(domain, 16).unwrap();

            // Convert msg from indexed yaml to bytes (Vec<u8>)
            let msg = input["message"].as_str().unwrap();
            let msg = msg.trim_left_matches("0x");
            let msg = hex::decode(msg).unwrap();

            // Function results returns ECP2 point
            let mut result = hash_on_g2(&msg, domain);

            // Compare against given output
            let output = test_case["output"].clone().into_vec().unwrap();
            for (i, fp2) in output.iter().enumerate() {
                // Get x, y or z point from curve
                let mut result_fp2 = result.getpx();
                if i == 1 {
                    // Check y coordinate
                    result_fp2 = result.getpy();
                } else if i == 2 {
                    // Check z coordinate
                    result_fp2 = result.getpz();
                }

                let a = fp2[0].as_str().unwrap().trim_left_matches("0x");
                let b = fp2[1].as_str().unwrap().trim_left_matches("0x");

                assert_eq!(a.to_uppercase().as_str(), result_fp2.geta().tostring());
                assert_eq!(b.to_uppercase().as_str(), result_fp2.getb().tostring());
            }
        }
    }

    #[test]
    #[allow(non_snake_case)]
    fn case02_message_hash_G2_compressed() {
        // Run tests from test_bls.yml
        let mut file = {
            let mut file_path_buf = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
            file_path_buf.push("src/test_vectors/test_bls.yml");

            File::open(file_path_buf).unwrap()
        };
        let mut yaml_str = String::new();
        file.read_to_string(&mut yaml_str).unwrap();
        let docs = yaml::YamlLoader::load_from_str(&yaml_str).unwrap();
        let doc = &docs[0];

        // Select case01
        let test_cases = doc["case02_message_hash_G2_compressed"].as_vec().unwrap();

        // Verify input against output for each pair
        for test_case in test_cases {
            // Convert input to rust formats
            let input = test_case["input"].clone();
            // Convert domain from indexed yaml to u64
            let domain = input["domain"].as_str().unwrap();
            let domain = domain.trim_left_matches("0x");
            let domain = u64::from_str_radix(domain, 16).unwrap();

            // Convert msg from indexed yaml to bytes (Vec<u8>)
            let msg = input["message"].as_str().unwrap();
            let msg = msg.trim_left_matches("0x");
            let msg = hex::decode(msg).unwrap();

            // Function results returns ECP2 point
            let mut result = hash_on_g2(&msg, domain);
            result.affine();

            // Compare against given output
            let output = test_case["output"].clone();
            // Compresed only compares x

            let mut result_fp2 = result.getx();

            let a = output[0].as_str().unwrap().trim_left_matches("0x").trim_left_matches("0");
            let b = output[1].as_str().unwrap().trim_left_matches("0x").trim_left_matches("0");

            // We need to add the compressed Y value to the begining of results_fp2.a
            assert_eq!(a.to_uppercase().as_str(), result_fp2.geta().tostring().trim_left_matches("0"));
            assert_eq!(b.to_uppercase().as_str(), result_fp2.getb().tostring().trim_left_matches("0"));
        }
    }
}
