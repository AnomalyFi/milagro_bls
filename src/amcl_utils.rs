extern crate amcl;
extern crate blake2_rfc;
extern crate rand;

use self::amcl::arch::Chunk;
use self::blake2_rfc::blake2b::blake2b;
use BLSCurve::big::BIG;
use BLSCurve::big::{MODBYTES as bls381_MODBYTES, NLEN};
use BLSCurve::ecp::ECP;
use BLSCurve::ecp2::ECP2;
use BLSCurve::fp12::FP12 as bls381_FP12;
use BLSCurve::fp2::FP2 as bls381_FP2;
use BLSCurve::pair::{ate, fexp};
use BLSCurve::rom;

pub type BigNum = BIG;
pub type GroupG1 = ECP;
pub type GroupG2 = ECP2;
pub type FP2 = bls381_FP2;
pub type FP12 = bls381_FP12;

pub const CURVE_ORDER: [Chunk; NLEN] = rom::CURVE_ORDER;
pub const MODBYTES: usize = bls381_MODBYTES;

// Byte size of element in group G1, 1 extra byte for compression
pub const G1_BYTE_SIZE: usize = (2 * MODBYTES + 1) as usize;
// Byte size of element in group G2
pub const G2_BYTE_SIZE: usize = (4 * MODBYTES) as usize;
// Byte size of secret key
pub const MOD_BYTE_SIZE: usize = bls381_MODBYTES;

lazy_static! {
    pub static ref GeneratorG1: GroupG1 = GroupG1::generator();
    pub static ref GeneratorG2: GroupG2 = GroupG2::generator();
}

pub fn hash_on_g2(msg: &[u8], d: u64) -> GroupG2 {
    let x_real = blake2b(49, &[], &[msg, &d.to_be_bytes(), &[1]].concat());
    let x_imaginary = blake2b(49, &[], &[msg, &d.to_be_bytes(), &[2]].concat());
    map_to_g2(&x_real.as_bytes(), &x_imaginary.as_bytes())
}

// The following function is a modified version of ECP2::mapit()
// It varies in having both x_real and x_imaginary parts generated by different hashes
#[allow(non_snake_case)]
pub fn map_to_g2(x_real: &[u8], x_imaginary: &[u8]) -> GroupG2 {
    let q = BIG::new_ints(&rom::MODULUS);
    let mut x_real = BIG::frombytes(x_real);
    let mut x_imaginary = BIG::frombytes(x_imaginary);
    x_real.rmod(&q);
    x_imaginary.rmod(&q);
    let mut Q: ECP2;

    loop {
        let X = FP2::new_bigs(&x_real, &x_imaginary);
        Q = GroupG2::new_fp2(&X);

        if !Q.is_infinity() {
            break;
        }
        x_real.inc(1);
        x_real.norm();
    }

    let mut X = FP2::new_bigs(&BIG::new_ints(&rom::FRA), &BIG::new_ints(&rom::FRB));
    X.inverse();
    X.norm();
    let x = BIG::new_ints(&rom::CURVE_BNX);
    let mut xQ = Q.mul(&x);
    let mut x2Q = xQ.mul(&x);
    xQ.neg();
    x2Q.sub(&xQ);
    x2Q.sub(&Q);
    xQ.sub(&Q);
    xQ.frob(&X);
    Q.dbl();
    Q.frob(&X);
    Q.frob(&X);
    Q.add(&x2Q);
    Q.add(&xQ);
    Q.affine();
    Q
}

pub fn ate_pairing(point_g2: &GroupG2, point_g1: &GroupG1) -> FP12 {
    let e = ate(&point_g2, &point_g1);
    fexp(&e)
}
